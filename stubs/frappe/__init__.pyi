"""
This type stub file was generated by pyright.
"""

import types
from typing import Any, Literal, TypeAlias, overload
from .exceptions import *
from .types.frappedict import _dict
from .utils.jinja import get_jenv as get_jenv, get_jloader as get_jloader, get_template as get_template, render_template as render_template
from .utils.lazy_loader import lazy_import as lazy_import
from _typeshed import Incomplete
from collections.abc import Callable as Callable
from frappe.database.mariadb.database import MariaDBDatabase as MariaDBDatabase
from frappe.database.postgres.database import PostgresDatabase as PostgresDatabase
from frappe.email.doctype.email_queue.email_queue import EmailQueue as EmailQueue
from frappe.model.document import Document as Document
from frappe.query_builder import get_query as get_query, get_query_builder as get_query_builder, patch_query_aggregation as patch_query_aggregation, patch_query_execute as patch_query_execute
from frappe.query_builder.builder import MariaDB as MariaDB, Postgres as Postgres
from frappe.utils.caching import request_cache as request_cache
from frappe.utils.data import cint as cint, cstr as cstr, sbool as sbool
from frappe.utils.error import log_error as log_error
from frappe.utils.print_utils import get_print as get_print
from frappe.utils.redis_wrapper import RedisWrapper as RedisWrapper
from typing import Any, Literal, overload
from werkzeug.wrappers import Request as Request

__version__: str
db: MariaDBDatabase | PostgresDatabase
qb: MariaDB | Postgres
cache: RedisWrapper
response: _dict
conf: _dict
form_dict: _dict
flags: _dict
request: Request
session: _dict
user: str
lang: str
controllers: Incomplete
local: Incomplete
STANDARD_USERS: Incomplete


_SingleDocument: TypeAlias = "Document"
_NewDocument: TypeAlias = "Document"

def _(msg: str, lang: str | None = ..., context: str | None = ...) -> str:
    ...

def as_unicode(text, encoding: str = ...) -> str:
    ...

def set_user_lang(user: str, user_language: str | None = ...) -> None:
    ...

form: Incomplete
job: Incomplete
error_log: Incomplete
debug_log: Incomplete
message_log: Incomplete
def init(site: str, sites_path: str = ..., new_site: bool = ..., force: bool = ...) -> None:
    ...

def connect(site: str | None = ..., db_name: str | None = ..., set_admin_as_user: bool = ...) -> None:
    ...

def connect_replica() -> bool:
    ...

def get_site_config(sites_path: str | None = ..., site_path: str | None = ...) -> dict[str, Any]:
    ...

def get_common_site_config(sites_path: str | None = ...) -> dict[str, Any]:
    ...

def get_conf(site: str | None = ...) -> dict[str, Any]:
    ...

class init_site:
    site: Incomplete
    def __init__(self, site=...) -> None:
        ...
    
    def __enter__(self):
        ...
    
    def __exit__(self, type: type[BaseException] | None, value: BaseException | None, traceback: types.TracebackType | None) -> None:
        ...
    


def destroy() -> None:
    ...

def setup_redis_cache_connection() -> None:
    ...

def get_traceback(with_context: bool = ...) -> str:
    ...

def errprint(msg: str) -> None:
    ...

def print_sql(enable: bool = ...) -> None:
    ...

def log(msg: str) -> None:
    ...

def msgprint(msg: str, title: str | None = ..., raise_exception: bool | type[Exception] | Exception = ..., as_table: bool = ..., as_list: bool = ..., indicator: Literal['blue', 'green', 'orange', 'red', 'yellow'] | None = ..., alert: bool = ..., primary_action: str | None = ..., is_minimizable: bool = ..., wide: bool = ..., *, realtime: bool = ...) -> None:
    ...

def clear_messages() -> None:
    ...

def get_message_log() -> list[dict]:
    ...

def clear_last_message() -> None:
    ...

def throw(msg: str, exc: type[Exception] | Exception = ..., title: str | None = ..., is_minimizable: bool = ..., wide: bool = ..., as_list: bool = ..., primary_action=...) -> None:
    ...

def create_folder(path, with_init: bool = ...) -> None:
    ...

def set_user(username: str):
    ...

def get_user():
    ...

def get_roles(username=...) -> list[str]:
    ...

def get_request_header(key, default=...):
    ...

def sendmail(recipients=..., sender: str = ..., subject: str = ..., message: str = ..., as_markdown: bool = ..., delayed: bool = ..., reference_doctype=..., reference_name=..., unsubscribe_method=..., unsubscribe_params=..., unsubscribe_message=..., add_unsubscribe_link: int = ..., attachments=..., content=..., doctype=..., name=..., reply_to=..., queue_separately: bool = ..., cc=..., bcc=..., message_id=..., in_reply_to=..., send_after=..., expose_recipients=..., send_priority: int = ..., communication=..., retry: int = ..., now=..., read_receipt=..., is_notification: bool = ..., inline_images=..., template=..., args=..., header=..., print_letterhead: bool = ..., with_container: bool = ..., email_read_tracker_url=..., x_priority: Literal[1, 3, 5] = ..., email_headers=...) -> EmailQueue | None:
    ...

whitelisted: Incomplete
guest_methods: Incomplete
xss_safe_methods: Incomplete
allowed_http_methods_for_whitelisted_func: Incomplete
def whitelist(allow_guest: bool = ..., xss_safe: bool = ..., methods=...):
    ...

def is_whitelisted(method) -> None:
    ...

def read_only():
    ...

def write_only():
    ...

def only_for(roles: list[str] | tuple[str] | str, message: bool = ...):
    ...

def get_domain_data(module):
    ...

def clear_cache(user: str | None = ..., doctype: str | None = ...):
    ...

def only_has_select_perm(doctype, user=..., ignore_permissions: bool = ...):
    ...

def has_permission(doctype=..., ptype: str = ..., doc=..., user=..., throw: bool = ..., *, parent_doctype=..., debug: bool = ..., ignore_share_permissions: bool = ...):
    ...

def has_website_permission(doc=..., ptype: str = ..., user=..., verbose: bool = ..., doctype=...):
    ...

def is_table(doctype: str) -> bool:
    ...

def get_precision(doctype: str, fieldname: str, currency: str | None = ..., doc: Document | None = ...) -> int:
    ...

def generate_hash(txt: str | None = ..., length: int = ...) -> str:
    ...

def reset_metadata_version():
    ...

def new_doc(doctype: str, *, parent_doc: Document | None = ..., parentfield: str | None = ..., as_dict: bool = ..., **kwargs) -> Document:
    ...

def set_value(doctype, docname, fieldname, value=...):
    ...

def get_cached_doc(*args, **kwargs) -> Document:
    ...

def can_cache_doc(args) -> str | None:
    ...

def get_document_cache_key(doctype: str, name: str):
    ...

def clear_document_cache(doctype: str, name: str | None = ...) -> None:
    ...

def get_cached_value(doctype: str, name: str, fieldname: str = ..., as_dict: bool = ...) -> Any:
    ...

@overload
def get_doc(document: Document, /) -> Document:
    ...

@overload
def get_doc(doctype: str, /) -> _SingleDocument:
    ...

@overload
def get_doc(doctype: str, name: str, /, *, for_update: bool | None = ...) -> Document:
    ...

@overload
def get_doc(**kwargs: dict) -> _NewDocument:
    ...

@overload
def get_doc(documentdict: dict) -> _NewDocument:
    ...

def get_single_value(setting: str, fieldname: str, /, *, as_dict: bool = ...):
    ...

def get_last_doc(doctype, filters=..., order_by: str = ..., *, for_update: bool = ...):
    ...

def get_single(doctype):
    ...

def get_meta(doctype, cached: bool = ...):
    ...

def get_meta_module(doctype):
    ...

def delete_doc(doctype: str | None = ..., name: str | None = ..., force: bool = ..., ignore_doctypes: list[str] | None = ..., for_reload: bool = ..., ignore_permissions: bool = ..., flags: None = ..., ignore_on_trash: bool = ..., ignore_missing: bool = ..., delete_permanently: bool = ...):
    ...

def delete_doc_if_exists(doctype, name, force: int = ...) -> None:
    ...

def reload_doctype(doctype, force: bool = ..., reset_permissions: bool = ...) -> None:
    ...

def reload_doc(module: str, dt: str | None = ..., dn: str | None = ..., force: bool = ..., reset_permissions: bool = ...):
    ...

def rename_doc(doctype: str, old: str, new: str, force: bool = ..., merge: bool = ..., *, ignore_if_exists: bool = ..., show_alert: bool = ..., rebuild_search: bool = ...) -> str:
    ...

def get_module(modulename):
    ...

def scrub(txt: str) -> str:
    ...

def unscrub(txt: str) -> str:
    ...

def get_module_path(module, *joins):
    ...

def get_app_path(app_name, *joins):
    ...

def get_app_source_path(app_name, *joins):
    ...

def get_site_path(*joins):
    ...

def get_pymodule_path(modulename, *joins):
    ...

def get_module_list(app_name):
    ...

def get_all_apps(with_internal_apps: bool = ..., sites_path=...):
    ...

@request_cache
def get_installed_apps(*, _ensure_on_bench: bool = ...) -> list[str]:
    ...

def get_doc_hooks():
    ...

def get_hooks(hook: str | None = ..., default: Any | None = ..., app_name: str | None = ...) -> _dict:
    ...

def append_hook(target, key, value) -> None:
    ...

def setup_module_map(include_all_apps: bool = ...) -> None:
    ...

def get_file_items(path, raise_not_found: bool = ..., ignore_empty_lines: bool = ...):
    ...

def get_file_json(path):
    ...

def read_file(path, raise_not_found: bool = ..., as_base64: bool = ...):
    ...

def get_attr(method_string: str) -> Any:
    ...

def call(fn: str | Callable, *args, **kwargs):
    ...

def get_newargs(fn: Callable, kwargs: dict[str, Any]) -> dict[str, Any]:
    ...

def make_property_setter(args, ignore_validate: bool = ..., validate_fields_for_doctype: bool = ..., is_system_generated: bool = ..., *, module=...) -> None:
    ...

def import_doc(path) -> None:
    ...

def copy_doc(doc: Document, ignore_no_copy: bool = ...) -> Document:
    ...

def respond_as_web_page(title, html, success=..., http_status_code=..., context=..., indicator_color=..., primary_action: str = ..., primary_label=..., fullpage: bool = ..., width=..., template: str = ...) -> None:
    ...

def redirect(url) -> None:
    ...

def redirect_to_message(title, html, http_status_code=..., context=..., indicator_color=...):
    ...

def build_match_conditions(doctype, as_condition: bool = ...):
    ...

def get_list(doctype, *args, **kwargs):
    ...

def get_all(doctype, *args, **kwargs):
    ...

def get_value(*args, **kwargs):
    ...

def as_json(obj: dict | list, indent: int = ..., separators=..., ensure_ascii: bool = ...) -> str:
    ...

def are_emails_muted():
    ...

def get_test_records(doctype):
    ...

def format_value(*args, **kwargs):
    ...

def format(*args, **kwargs):
    ...

def attach_print(doctype, name, file_name=..., print_format=..., style=..., html=..., doc=..., lang=..., print_letterhead: bool = ..., password=..., letterhead=...):
    ...

def publish_progress(*args, **kwargs):
    ...

def publish_realtime(*args, **kwargs):
    ...

def local_cache(namespace, key, generator, regenerate_if_none: bool = ...):
    ...

def enqueue(*args, **kwargs):
    ...

def task(**task_kwargs):
    ...

def enqueue_doc(*args, **kwargs):
    ...

def get_doctype_app(doctype):
    ...

loggers: Incomplete
log_level: Incomplete
def logger(module=..., with_more_info: bool = ..., allow_site: bool = ..., filter=..., max_size: int = ..., file_count: int = ...):
    ...

def get_desk_link(doctype, name, show_title_with_name: bool = ...):
    ...

def bold(text):
    ...

def safe_eval(code, eval_globals=..., eval_locals=...):
    ...

def get_website_settings(key):
    ...

def get_system_settings(key: str):
    ...

def get_active_domains():
    ...

def get_version(doctype, name, limit=..., head: bool = ..., raise_err: bool = ...):
    ...

@request_cache
def is_setup_complete():
    ...

def ping():
    ...

def safe_encode(param, encoding: str = ...):
    ...

def safe_decode(param, encoding: str = ..., fallback_map: dict | None = ...):
    ...

def parse_json(val):
    ...

def mock(type, size: int = ..., locale: str = ...):
    ...

def validate_and_sanitize_search_inputs(fn):
    ...

def override_whitelisted_method(original_method: str) -> str:
    ...

g0: Incomplete
g1: Incomplete
g2: Incomplete
get_lazy_doc = ...
